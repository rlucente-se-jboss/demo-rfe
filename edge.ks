# set locale defaults for the Install
lang en_US.UTF-8
keyboard us
timezone UTC

# initialize any invalid partition tables and destroy all of their contents
zerombr

# erase all disk partitions and create a default label
clearpart --all --initlabel

# automatically create xfs partitions with no LVM and no /home partition
autopart --type=plain --fstype=xfs --nohome

# reboot after installation is successfully completed
reboot

# installation will run in text mode
text

# activate network devices and configure with DHCP
network --bootproto=dhcp

# create default user 'core' with sudo privileges using password 'edge'
user --name=core --groups=wheel --password=edge

# set up the OSTree-based install with disabled GPG key verification, the base
# URL to pull the installation content, 'rhel' as the management root in the
# repo, and 'rhel/8/x86_64/edge' as the branch for the installation
ostreesetup --nogpg --url=http://192.168.1.100:8000/repo/ --osname=rhel --remote=edge --ref=rhel/8/x86_64/edge
%post

# Set the update policy to automatically download and stage updates to be
# applied at the next reboot
#stage updates as they become available. This is highly recommended
echo AutomaticUpdatePolicy=stage >> /etc/rpm-ostreed.conf

# This systemd service runs one time and exits. If there are staged updates to
# the operating system, the system is rebooted to apply them.
#This is a simple example that will look for staged rpm-ostree updates and apply them per the timer if they exist
cat > /etc/systemd/system/applyupdate.service << 'EOF'
[Unit]
Description=Apply Update Check

[Service]
Type=oneshot
ExecStart=/bin/sh -c 'if [[ $(rpm-ostree status -v | grep "Staged: yes") ]]; then systemctl --message="Applying OTA update" reboot; else logger "Running latest available update"; fi'
EOF

# This systemd timer activates once per day at 01:30 am (UTC) to check for
# staged updates to the operating system
cat > /etc/systemd/system/applyupdate.timer << EOF
[Unit]
Description=Daily Update Reboot Check.

[Timer]
# activate every minute
OnBootSec=60
OnUnitActiveSec=60

#weekly example for Sunday at midnight
#OnCalendar=Sun *-*-* 00:00:00

[Install]
WantedBy=multi-user.target
EOF

# The rpm-ostreed-automatic.timer and accompanying service will check for
# operating system updates and stage them
systemctl enable rpm-ostreed-automatic.timer applyupdate.timer
%end

%post
#Add a podman autoupdate timer & service

# podman auto-update looks up containers with a specified
# "io.containers.autoupdate" label (i.e., the auto-update policy).
#
# If the label is present and set to “image”, Podman reaches out to the
# corresponding registry to check if the image has been updated. An image is
# considered updated if the digest in the local storage is different than the
# one of the remote image. If an image must be updated, Podman pulls it down
# and restarts the systemd unit executing the container.

cat > /etc/systemd/system/podman-auto-update.service << EOF
[Unit]
Description=Podman auto-update service
Documentation=man:podman-auto-update(1)
Wants=network.target
After=network-online.target

[Service]
ExecStart=/usr/bin/podman auto-update

[Install]
WantedBy=multi-user.target default.target
EOF

# The podman auto-update is run daily within a two-hour randomized window to
# reduce system load
cat > /etc/systemd/system/podman-auto-update.timer << EOF
[Unit]
Description=Podman auto-update timer

[Timer]
#OnCalendar=daily
#Persistent=true
#RandomizedDelaySec=7200

# activate every minute
OnBootSec=60
OnUnitActiveSec=60

[Install]
WantedBy=timers.target
EOF

#create a unit file to run our example workload
cat > /etc/systemd/system/container-httpd.service <<EOF
# container-httpd.service
# autogenerated by Podman 2.0.5
# Fri Dec  4 20:22:56 EST 2020

[Unit]
Description=Podman container-httpd.service
Documentation=man:podman-generate-systemd(1)
Requires=network.target
After=network-online.target

[Service]
Environment=PODMAN_SYSTEMD_UNIT=%n
Restart=on-failure
ExecStartPre=/bin/rm -f %t/container-httpd.pid %t/container-httpd.ctr-id
ExecStart=/usr/bin/podman run --conmon-pidfile %t/container-httpd.pid --cidfile %t/container-httpd.ctr-id --cgroups=no-conmon --replace -d --label io.containers.autoupdate=image --name httpd -p 8080:80 192.168.1.100:5000/httpd:prod
ExecStop=/usr/bin/podman stop --ignore --cidfile %t/container-httpd.ctr-id -t 10
ExecStopPost=/usr/bin/podman rm --ignore -f --cidfile %t/container-httpd.ctr-id
PIDFile=%t/container-httpd.pid
KillMode=none
Type=forking

[Install]
WantedBy=multi-user.target default.target
EOF

cat > /etc/containers/registries.conf <<EOF
[registries.search]
registries = ['registry.access.redhat.com', 'registry.redhat.io', 'docker.io']
[registries.insecure]
registries = ['192.168.1.100:5000']
[registries.block]
registries = []
EOF

systemctl enable podman-auto-update.timer container-httpd.service
%end

%post
mkdir -p /etc/greenboot/check/required.d
cat > /etc/greenboot/check/required.d/01_fail_upgrade.sh <<EOF
#!/bin/bash

#
# This test fails if the current commit is different than the original commit
#

if [ ! -f /etc/greenboot/orig.txt ]
then
    rpm-ostree status | grep -A2 '^\*' | grep Commit > /etc/greenboot/orig.txt
fi

rpm-ostree status | grep -A2 '^\*' | grep Commit > /etc/greenboot/current.txt

diff -s /etc/greenboot/orig.txt /etc/greenboot/current.txt
EOF

chmod +x /etc/greenboot/check/required.d/01_fail_upgrade.sh
%end
